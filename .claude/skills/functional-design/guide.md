# 機能設計ガイドライン

## 機能設計書の目的

機能設計書は、PRDで定義された要件を実装可能なレベルまで詳細化するドキュメントです。開発者がこのドキュメントを読むだけで実装できる状態を目指します。

## 作成時の原則

### 1. 実装可能なレベルまで詳細化

**良い例:**
```
#### 処理フロー
1. ユーザーがメールアドレスとパスワードを入力
2. クライアント側でバリデーション（メール形式、パスワード8文字以上）
3. POST /api/v1/auth/login にリクエスト送信
4. サーバー側でパスワードをbcryptで検証
5. 成功時: JWTトークン（有効期限24時間）を返却
6. 失敗時: 401エラーとエラーメッセージを返却
```

**悪い例:**
```
ユーザーがログインする
```

### 2. エッジケースを網羅する

すべての想定外のケースを考慮します。

**考慮すべきエッジケース:**
- 入力値が空の場合
- 入力値が制限を超える場合（長すぎる、大きすぎる等）
- ネットワークエラー
- タイムアウト
- 同時実行の競合
- データが存在しない場合

### 3. セキュリティを最優先

**チェックリスト:**
- [ ] 認証が必要なエンドポイントか
- [ ] 認可（権限チェック）が必要か
- [ ] 入力値の検証は十分か
- [ ] SQLインジェクション対策はあるか
- [ ] XSS対策はあるか
- [ ] CSRF対策はあるか
- [ ] センシティブ情報のログ出力を避けているか

## API設計のベストプラクティス

### RESTful API 設計

#### リソース指向の設計

**良い例:**
- `GET /api/v1/users` - ユーザー一覧取得
- `GET /api/v1/users/:id` - 特定ユーザー取得
- `POST /api/v1/users` - ユーザー作成
- `PUT /api/v1/users/:id` - ユーザー更新
- `DELETE /api/v1/users/:id` - ユーザー削除

**悪い例:**
- `GET /api/v1/getUsers`
- `POST /api/v1/createUser`

#### HTTPステータスコードの適切な使用

- `200 OK`: 成功（GET, PUT, PATCH）
- `201 Created`: リソース作成成功（POST）
- `204 No Content`: 成功だがレスポンスボディなし（DELETE）
- `400 Bad Request`: クライアント側のエラー（バリデーションエラー等）
- `401 Unauthorized`: 認証エラー
- `403 Forbidden`: 認可エラー（権限不足）
- `404 Not Found`: リソースが見つからない
- `500 Internal Server Error`: サーバー側のエラー

### リクエスト/レスポンス設計

#### 一貫性のあるレスポンス形式

**成功レスポンス:**
```json
{
  "status": "success",
  "data": {
    "user": {
      "id": "123",
      "name": "John Doe",
      "email": "john@example.com"
    }
  }
}
```

**エラーレスポンス:**
```json
{
  "status": "error",
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid input",
    "details": [
      {
        "field": "email",
        "message": "Invalid email format"
      }
    ]
  }
}
```

#### ページネーション

リスト取得APIには必ずページネーションを実装:

**リクエスト:**
```
GET /api/v1/users?page=1&limit=20
```

**レスポンス:**
```json
{
  "status": "success",
  "data": {
    "users": [...],
    "pagination": {
      "page": 1,
      "limit": 20,
      "total": 100,
      "totalPages": 5
    }
  }
}
```

## バリデーション設計

### クライアント側バリデーション

即座にフィードバックを提供するため、クライアント側でも基本的なバリデーションを実施。

### サーバー側バリデーション

セキュリティのため、すべての入力値をサーバー側で必ず検証。

### バリデーションルールの例

| フィールド | 型 | 必須 | 制約 | エラーメッセージ |
|-----------|-----|------|------|------------------|
| email | string | ○ | メール形式、最大255文字 | 有効なメールアドレスを入力してください |
| password | string | ○ | 8文字以上、英数字記号を含む | パスワードは8文字以上で、英数字と記号を含む必要があります |
| age | number | × | 0以上120以下 | 年齢は0〜120の範囲で入力してください |

## エラーハンドリング

### エラーの分類

1. **バリデーションエラー**: ユーザー入力の不備
2. **認証エラー**: ログインが必要
3. **認可エラー**: 権限不足
4. **ビジネスロジックエラー**: ビジネスルール違反
5. **システムエラー**: データベース接続エラー等

### エラーコード設計

```typescript
enum ErrorCode {
  // バリデーションエラー (4000-4999)
  VALIDATION_ERROR = 4000,
  INVALID_EMAIL = 4001,
  INVALID_PASSWORD = 4002,

  // 認証エラー (5000-5999)
  UNAUTHORIZED = 5000,
  INVALID_TOKEN = 5001,
  TOKEN_EXPIRED = 5002,

  // 認可エラー (6000-6999)
  FORBIDDEN = 6000,
  INSUFFICIENT_PERMISSIONS = 6001,

  // ビジネスロジックエラー (7000-7999)
  USER_NOT_FOUND = 7000,
  EMAIL_ALREADY_EXISTS = 7001,

  // システムエラー (9000-9999)
  INTERNAL_SERVER_ERROR = 9000,
  DATABASE_ERROR = 9001,
}
```

## データフロー設計

### 処理の流れを明確に

```
[クライアント]
  ↓ リクエスト
[APIルーター]
  ↓ ルーティング
[ミドルウェア（認証）]
  ↓ トークン検証
[ミドルウェア（バリデーション）]
  ↓ 入力値検証
[コントローラー]
  ↓ リクエストハンドリング
[ユースケース/サービス]
  ↓ ビジネスロジック実行
[リポジトリ]
  ↓ データアクセス
[データベース]
  ↓ データ取得/保存
[レスポンス整形]
  ↓
[クライアント]
```

## 状態遷移設計

### 状態の定義

各機能で扱う状態を明確に定義:

**例: 注文の状態**
```
[下書き] → [注文確定] → [支払い済み] → [発送準備中] → [発送済み] → [配達完了]
                ↓
           [キャンセル]
```

### 状態遷移のルール

どの状態からどの状態に遷移できるかを明確に:

| 現在の状態 | 可能な遷移先 | 条件 |
|-----------|-------------|------|
| 下書き | 注文確定、キャンセル | - |
| 注文確定 | 支払い済み、キャンセル | 支払い期限内 |
| 支払い済み | 発送準備中 | - |
| 発送準備中 | 発送済み | 在庫あり |
| 発送済み | 配達完了 | - |

## セキュリティ考慮事項

### 認証

- JWTトークンを使用
- トークンの有効期限を設定（推奨: 24時間）
- リフレッシュトークンで自動更新

### 認可

- ロールベースアクセス制御（RBAC）
- リソースごとに権限チェック
- 最小権限の原則

### 入力値検証

- すべての入力値をサーバー側で検証
- ホワイトリスト方式を採用
- 型チェック、長さチェック、形式チェック

### OWASP Top 10 対策

1. **SQLインジェクション**: ORM/パラメータ化クエリを使用
2. **XSS**: 出力時にエスケープ処理
3. **CSRF**: CSRFトークンを使用
4. **認証の不備**: 強力なパスワードポリシー、MFA
5. **機密データの露出**: HTTPS通信、パスワードのハッシュ化
6. **アクセス制御の不備**: 認可チェックの徹底
7. **セキュリティ設定ミス**: セキュアなデフォルト設定
8. **XSS**: Content Security Policy (CSP)
9. **安全でないデシリアライゼーション**: 信頼できるソースのみ
10. **脆弱なコンポーネント**: 依存関係の定期的な更新

## チェックリスト

機能設計完了前に以下を確認:

- [ ] 各機能の目的が明確である
- [ ] 処理フローが実装可能なレベルまで詳細化されている
- [ ] すべてのAPI仕様が定義されている（リクエスト、レスポンス、エラー）
- [ ] バリデーションルールが定義されている
- [ ] エッジケースが考慮されている
- [ ] エラーハンドリングが定義されている
- [ ] セキュリティ考慮事項が記載されている
- [ ] データフローが明確である
- [ ] 状態遷移が定義されている（状態を持つ機能の場合）

## よくある間違い

### 1. 実装方法を指定しすぎる

機能設計では「何を」実装するかを記述し、「どう」実装するかは開発者に委ねます。

**悪い例:** 「Redisを使ってキャッシュする」
**良い例:** 「APIレスポンスを5分間キャッシュする」

### 2. エラーケースの考慮不足

正常系だけでなく、異常系も必ず記述します。

### 3. API仕様の曖昧さ

リクエスト・レスポンスの形式を具体的なJSONで示します。

### 4. セキュリティの後回し

セキュリティは最初から考慮し、設計に組み込みます。
